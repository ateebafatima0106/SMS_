/* import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:pdf/pdf.dart';
import 'package:printing/printing.dart';
import 'package:school_management_system/controllers/authController.dart';
import 'package:school_management_system/dashboard/Drawer_Screens/singleMarksheetScreen.dart';
import 'package:school_management_system/models/singleMarksheetModel.dart';
import 'package:school_management_system/services/api_services.dart';


class MarksheetController extends GetxController {
  var isLoading = false.obs;
  var isGeneratingPdf = false.obs;
  var marksheet = Rx<MarksheetModel?>(null);

  final String marksheetEndpoint ="/Marksheet/Get-Marksheet-Single"; // replace with your actual endpoint

  @override
  void onInit() {
    super.onInit();
    loadMarksheet();
  }

  Future<void> loadMarksheet() async {
    try {
      isLoading.value = true;
      final data = await ApiService.getRequest(endpoint: marksheetEndpoint);
      marksheet.value = MarksheetModel.fromJson(data);
    } catch (e) {
      Get.snackbar("Error", "$e");
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> generatePdf() async {
    if (marksheet.value == null) return;

    isGeneratingPdf.value = true;
    try {
      final pdf = pw.Document();
      final data = marksheet.value!;

      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(32),
          build: (context) => _buildPdfContent(data),
        ),
      );

      await Printing.sharePdf(
        bytes: await pdf.save(),
        filename:
            'Marksheet_${data.studentInfo.name.replaceAll(' ', '_')}.pdf',
      );
    } catch (e) {
      Get.snackbar('Error', 'Failed to generate PDF: $e');
    } finally {
      isGeneratingPdf.value = false;
    }
  }

  pw.Widget _buildPdfContent(MarksheetModel data) {
    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        _buildPdfHeader(),
        pw.SizedBox(height: 20),
        _buildPdfStudentInfo(data.studentInfo),
        pw.SizedBox(height: 20),
        _buildPdfMarksTable(data.subjects),
        pw.SizedBox(height: 20),
        _buildPdfFooter(),
      ],
    );
  }

  pw.Widget _buildPdfHeader() {
    return pw.Center(
      child: pw.Column(
        children: [
          pw.Text("SCHOOL LOGO HERE"), // Keep your logo here
          pw.SizedBox(height: 10),
          pw.Text("School Name", style: pw.TextStyle(fontSize: 20)),
          pw.Text("School Tagline"),
        ],
      ),
    );
  }

  pw.Widget _buildPdfStudentInfo(StudentInfo student) {
    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        pw.Text("Name: ${student.name}"),
        pw.Text("Roll No: ${student.rollNo}"),
        pw.Text("Class: ${student.className}"),
        pw.Text("Session: ${student.session}"),
      ],
    );
  }

  pw.Widget _buildPdfMarksTable(List<SubjectMark> subjects) {
    return pw.Table.fromTextArray(
      headers: ["Subject", "Max Marks", "Pass Marks", "Obtained Marks"],
      data: subjects
          .map((e) => [
                e.subjectName,
                e.maximumMarks.toString(),
                e.passingMarks.toString(),
                e.obtainedMarks.toString()
              ])
          .toList(),
    );
  }

  pw.Widget _buildPdfFooter() {
    return pw.Center(
      child: pw.Text("Generated by School Management App"),
    );
  }
}  
class MarksheetController extends GetxController {
  var isLoading = false.obs;
  var isGeneratingPdf = false.obs;

  var marksList = <MarksheetModel>[].obs;

  var tasks = [].obs;
  var selectedTaskId = "".obs;

  final studentIdController = TextEditingController();
  final classController = TextEditingController();

  @override
  void onInit() {
    super.onInit();
    loadTasks();
  }

  // -------------------------------
  // LOAD TASKS FOR DROPDOWN
  // -------------------------------
  Future<void> loadTasks() async {
    try {
      final response = await ApiService.getRequest(
        endpoint: "/Marksheet/tasks",
        token: AuthController.to.token,
      );
      tasks.value = response;
    } catch (e) {
      Get.snackbar("Error", "Failed to load tasks");
    }
  }

  // -------------------------------
  // LOAD MARKSHEET (DYNAMIC)
  // -------------------------------
  Future<void> loadMarksheet() async {
    if (studentIdController.text.isEmpty ||
        classController.text.isEmpty ||
        selectedTaskId.value.isEmpty) {
      Get.snackbar("Error", "Fill all fields");
      return;
    }

    try {
      isLoading.value = true;

      final uriParams = {
        "studentId": studentIdController.text,
        "ClassDesc": classController.text,
        "taskId": selectedTaskId.value,
      };

      final response = await ApiService.getRequestWithParams(
        endpoint: "/Marksheet/Get-Marksheet-Single",
        queryParams: uriParams,
        token: AuthController.to.token,
      );

      marksList.value = (response as List)
          .map((e) => MarksheetModel.fromJson(e))
          .toList();
    } catch (e) {
      Get.snackbar("Error", "Marksheet not found");
    } finally {
      isLoading.value = false;
    }
  }

  // -------------------------------
  // GENERATE PDF (DESIGN SAME)
  // -------------------------------
  Future<void> generatePdf() async {
    if (marksList.isEmpty) return;

    isGeneratingPdf.value = true;

    final pdf = pw.Document();
    final student = marksList.first;

    pdf.addPage(
      pw.Page(
        build: (context) {
          return pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Center(
                child: pw.Column(
                  children: [
                    pw.Text("School Name", style: pw.TextStyle(fontSize: 20)),
                    pw.Text("School Tagline"),
                  ],
                ),
              ),
              pw.SizedBox(height: 20),
              pw.Text("Name: ${student.name}"),
              pw.Text("Roll No: ${student.rollNo}"),
              pw.Text("Class: ${student.classDesc}"),
              pw.SizedBox(height: 20),
              pw.Table.fromTextArray(
                headers: ["Subject", "Max", "Pass", "Obtained"],
                data: marksList
                    .map((e) => [
                          e.subjectName,
                          e.totalMarks.toString(),
                          e.passingMarks.toString(),
                          e.obtMarks.toString(),
                        ])
                    .toList(),
              ),
            ],
          );
        },
      ),
    );

    await Printing.sharePdf(
      bytes: await pdf.save(),
      filename: "Marksheet_${student.name}.pdf",
    );

    isGeneratingPdf.value = false;
  }
} 


    */
    